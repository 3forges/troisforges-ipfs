package badger

import (
	"encoding/json"
	"errors"
	"path/filepath"

	"github.com/dgraph-io/badger"
	"github.com/dgraph-io/badger/options"
	"github.com/kelseyhightower/envconfig"

	"github.com/ipfs/ipfs-cluster/config"
)

const configKey = "badger"
const envConfigKey = "cluster_badger"

// Default values for badger Config
const (
	DefaultSubFolder = "badger"
)

var (
	// DefaultBadgerOptions has to be a var because badger.DefaultOptions is.
	DefaultBadgerOptions badger.Options
)

func init() {
	DefaultBadgerOptions = badger.DefaultOptions
}

// Config is used to initialize a BadgerDB datastore. It implements the
// ComponentConfig interface.
type Config struct {
	config.Saver

	// The folder for this datastore. Non-absolute paths are relative to
	// the base configuration folder.
	Folder string

	BadgerOptions badger.Options
}

// FileLoadingMode specifies how data in LSM table files and value log files should
// be loaded.
type FileLoadingMode int

const (
	// Unknown indicates that the value hasn't been set
	Unknown FileLoadingMode = iota
	// FileIO indicates that files must be loaded using standard I/O
	FileIO
	// LoadToRAM indicates that file must be loaded into RAM
	LoadToRAM
	// MemoryMap indicates that that the file must be memory-mapped
	MemoryMap
)

type jsonConfig struct {
	Folder              string          `json:"folder,omitempty"`
	TableLoadingMode    FileLoadingMode `json:"table_loading_mode,omitempty"`     // because we can't distinguish between options.FileIO and default value
	ValueLogLoadingMode FileLoadingMode `json:"value_log_loading_mode,omitempty"` // because we can't distinguish between options.FileIO and default value
}

// ConfigKey returns a human-friendly identifier for this type of Datastore.
func (cfg *Config) ConfigKey() string {
	return configKey
}

// Default initializes this Config with sensible values.
func (cfg *Config) Default() error {
	cfg.Folder = DefaultSubFolder
	cfg.BadgerOptions = DefaultBadgerOptions
	return nil
}

// ApplyEnvVars fills in any Config fields found as environment variables.
func (cfg *Config) ApplyEnvVars() error {
	jcfg := cfg.toJSONConfig()

	err := envconfig.Process(envConfigKey, jcfg)
	if err != nil {
		return err
	}

	return cfg.applyJSONConfig(jcfg)
}

// Validate checks that the fields of this Config have working values,
// at least in appearance.
func (cfg *Config) Validate() error {
	if cfg.Folder == "" {
		return errors.New("folder is unset")
	}

	return nil
}

// LoadJSON reads the fields of this Config from a JSON byteslice as
// generated by ToJSON.
func (cfg *Config) LoadJSON(raw []byte) error {
	jcfg := &jsonConfig{}
	err := json.Unmarshal(raw, jcfg)
	if err != nil {
		return err
	}

	cfg.Default()

	return cfg.applyJSONConfig(jcfg)
}

func (cfg *Config) applyJSONConfig(jcfg *jsonConfig) error {
	config.SetIfNotDefault(jcfg.Folder, &cfg.Folder)
	if v, ok := correctLoadingMode(jcfg.TableLoadingMode); ok {
		cfg.BadgerOptions.TableLoadingMode = options.FileLoadingMode(v)
	}
	if v, ok := correctLoadingMode(jcfg.ValueLogLoadingMode); ok {
		cfg.BadgerOptions.ValueLogLoadingMode = options.FileLoadingMode(v)
	}
	return cfg.Validate()
}

// ToJSON generates a JSON-formatted human-friendly representation of this
// Config.
func (cfg *Config) ToJSON() (raw []byte, err error) {
	jcfg := cfg.toJSONConfig()

	raw, err = config.DefaultJSONMarshal(jcfg)
	return
}

func (cfg *Config) toJSONConfig() *jsonConfig {
	jCfg := &jsonConfig{}

	if cfg.Folder != DefaultSubFolder {
		jCfg.Folder = cfg.Folder
		jCfg.TableLoadingMode = FileLoadingMode(cfg.BadgerOptions.TableLoadingMode)
		jCfg.ValueLogLoadingMode = FileLoadingMode(cfg.BadgerOptions.ValueLogLoadingMode)
	}

	return jCfg
}

// GetFolder returns the BadgerDB folder.
func (cfg *Config) GetFolder() string {
	if filepath.IsAbs(cfg.Folder) {
		return cfg.Folder
	}

	return filepath.Join(cfg.BaseDir, cfg.Folder)
}

func correctLoadingMode(lm FileLoadingMode) (options.FileLoadingMode, bool) {
	switch lm {
	default:
		return 0, false
	case 1, 2, 3:
		return options.FileLoadingMode(lm - 1), true
	}
}
